#!/bin/sh

SCRIPT=$(readlink $0 || true)
if [ -z $SCRIPT ]; then
    SCRIPT=$0
fi;
SCRIPT_DIR="$(cd `dirname "$SCRIPT"` && pwd -P)"
RELEASE_ROOT_DIR="$(cd "$SCRIPT_DIR/.." && pwd -P)"
START_ERL=`cat $RELEASE_ROOT_DIR/releases/start_erl.data`
REL_NAME="wocky"
REL_VSN=${START_ERL#* }
ERTS_VSN=${START_ERL% *}
ERTS_PATH=$RELEASE_ROOT_DIR/erts-$ERTS_VSN/bin
REL_DIR="$RELEASE_ROOT_DIR/releases/$REL_VSN"
ERL=$ERTS_PATH/erl
EJABBERD_EBIN_PATH=$RELEASE_ROOT_DIR/lib/ejabberd-*/ebin/

# Use $CWD/vm.args if exists, otherwise releases/VSN/vm.args
if [ -z "$VMARGS_PATH" ]; then
    if [ -f "$RELEASE_ROOT_DIR/vm.args" ]; then
        VMARGS_PATH="$RELEASE_ROOT_DIR/vm.args"
    else
        VMARGS_PATH="$REL_DIR/vm.args"
    fi
fi

COOKIE_ARG=`grep -e '^-setcookie' $VMARGS_PATH`
if [ -z "$COOKIE_ARG" ]; then
    echo "vm.args needs to have a -setcookie parameter."
    exit 1
fi

NODENAME_ARG=`egrep -e '^-s?name' $VMARGS_PATH`
if [ -z "$NODENAME_ARG" ]; then
    echo "vm.args needs to have either -name or -sname parameter."
    exit 1
fi

NAME_TYPE="${NODENAME_ARG% *}"
NODENAME="${NODENAME_ARG#* }"

# Generate a random id
relx_gen_id() {
    od -X -N 4 /dev/urandom | head -n1 | awk '{print $2}'
}

relx_get_longname() {
    id="longname$(relx_gen_id)-${NAME}"
    "$ERL" -boot start_clean -eval 'io:format("~s~n", [node()]), halt()' -noshell -name $id | sed -e 's/.*@//g'
}

# User can specify an sname without @hostname
# This will fail when creating remote shell
# So here we check for @ and add @hostname if missing
case $NODENAME in
    *@*)
    # Nothing to do
    ;;
    *)
        # Add @hostname
        case $NAME_TYPE in
            -sname)
                NODENAME=$NODENAME@`hostname -s`
                ;;
            -name)
                NODENAME=$NODENAME@$(relx_get_longname)
                ;;
        esac
        ;;
esac

join_cluster()
{
    echo "Warning. This will drop all current connections and will discard all persistent data from Mnesia.
            Do you want to continue? (yes/no)"
    read GUARD

    if [ $GUARD =  "yes" ]; then
        echo "Joining the cluster..."
        ctl $QUOTED_ARGS
    else
        echo "Operation discarded by user"
        exit 1
    fi
}

leave_cluster()
{
    echo "Warning. This will drop all current connections and will discard all persistent data from Mnesia.
            Do you want to continue? (yes/no)"
    read GUARD

    if [ $GUARD =  "yes" ]; then
        echo "Leaving the cluster..."
        ctl $QUOTED_ARGS
    else
        echo "Operation discarded by user"
        exit 1
    fi
}

start ()
{
    $SCRIPT_DIR/wocky start
}

# attach to server
debug ()
{
    $SCRIPT_DIR/wocky remote_console
}

# start interactive server
live ()
{
    $SCRIPT_DIR/wocky console
}

help ()
{
    echo ""
    echo "Commands to start a wocky node:"
    echo "  start  Start a wocky node in server mode"
    echo "  debug  Attach an interactive Erlang shell to a running wocky node"
    echo "  live   Start wocky node in live (interactive) mode"
    echo "wocky cluster management commads:"
    echo "  join_cluster other_node_name       Add current node to cluster"
    echo "  leave_cluster                      Remove current node from cluster"
    echo ""
}

# common control function
ctl ()
{
    COMMAND=$@

    # Control number of connections identifiers
    # using flock if available. Expects a linux-style
    # flock that can lock a file descriptor.
    MAXCONNID=100
    CONNLOCKDIR=$RELEASE_ROOT_DIR/var/lock/wockyctl
    mkdir -p $CONNLOCKDIR
    FLOCK='/usr/bin/flock'
    if [ ! -x "$FLOCK" ] || [ ! -d "$CONNLOCKDIR" ] ; then
        JOT='/usr/bin/jot'
        if [ ! -x "$JOT" ] ; then
            # no flock or jot, simply invoke ctlexec()
            CTL_CONN="ctl-${NODENAME}"
            ctlexec $CTL_CONN $COMMAND
            result=$?
        else
            # no flock, but at least there is jot
            RAND=`jot -r 1 0 $MAXCONNID`
            CTL_CONN="ctl-${RAND}-${NODENAME}"
            ctlexec $CTL_CONN $COMMAND
            result=$?
        fi
    else
        # we have flock so we get a lock
        # on one of a limited number of
        # conn names -- this allows
        # concurrent invocations using a bound
        # number of atoms
        for N in $(seq 1 $MAXCONNID); do
            CTL_CONN="wockyctl-$N"
            CTL_LOCKFILE="$CONNLOCKDIR/$CTL_CONN"
            (
                exec 8>"$CTL_LOCKFILE"
                if flock --nb 8; then
                    ctlexec $CTL_CONN $COMMAND
                    ssresult=$?
                    # segregate from possible flock exit(1)
                    ssresult=$(expr $ssresult \* 10)
                    exit $ssresult
                else
                    exit 1
                fi
            )
            result=$?
            if [ $result -eq 1 ]; then
                # means we errored out in flock
                # rather than in the exec - stay in the loop
                # trying other conn names...
                badlock=1
            else
                badlock=""
                break;
            fi
        done
        result=$(expr $result / 10)
    fi

    if [ "$badlock" ]; then
        echo "Ran out of connections to try. Your wocky processes" >&2
        echo "may be stuck or this is a very busy server. For very"   >&2
        echo "busy servers, consider raising MAXCONNID in wockyctl">&2
        exit 1;
    fi

    case $result in
        0) :;;
        1) :;;
        2) help;;
        3) help;;
    esac
    return $result
}

ctlexec ()
{
    CONN_NAME=$1; shift
    COMMAND=$@
    $ERL \
      $NAME_TYPE ${CONN_NAME} \
      -boot start_clean \
      -noinput \
      -hidden \
      $COOKIE_ARG \
      -pa $EJABBERD_EBIN_PATH \
      -s ejabberd_ctl -extra $NODENAME $COMMAND
}

# display ctl usage
usage ()
{
    ctl
    exit
}

# stop epmd if there is no other running node
stop_epmd()
{
    epmd -names | grep -q name || epmd -kill
}

# allow sync calls
wait_for_status()
{
    # args: status try delay
    # return: 0 OK, 1 KO
    timeout=$2
    status=4
    while [ $status -ne $1 ]; do
        sleep $3
        timeout=$(($timeout - 1))
        [ $timeout -eq 0 ] && {
            status=$1
        } || {
            ctl status > /dev/null
            status=$?
        }
    done
    [ $timeout -eq 0 ] && {
        status=1
    } || {
        status=0
    }
    return $status
}


# parse command line parameters
ARGS=""; QUOTED_ARGS=""
for PARAM in "$@"
do
    case $PARAM in
        --)
            break ;;
        *)
            ARGS="$ARGS$PARAM"; ARGS="$ARGS ";
            QUOTED_ARGS=$QUOTED_ARGS'"'$PARAM'"'; QUOTED_ARGS=$QUOTED_ARGS" " ;;
    esac
done

case $1 in
    'start') start;;
    'join_cluster') join_cluster;;
    'leave_cluster') leave_cluster;;
    'debug') debug;;
    'live') live;;
    'started') wait_for_status 0 30 2;; # wait 30x2s before timeout
    'stopped') wait_for_status 3 15 2; stop_epmd;; # wait 15x2s before timeout
    *) ctl $QUOTED_ARGS;;
esac
